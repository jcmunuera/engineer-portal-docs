"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[1226],{8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var s=i(6540);const t={},a=s.createContext(t);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(a.Provider,{value:n},e.children)}},8956:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"ADRs/adr-001-Transactional-APIs","title":"ADR-001: Transactional Support in API-led Connectivity","description":"Purpose","source":"@site/../docs/ADRs/adr-001-Transactional-APIs.md","sourceDirName":"ADRs","slug":"/ADRs/adr-001-Transactional-APIs","permalink":"/engineer-portal-docs/docs/ADRs/adr-001-Transactional-APIs","draft":false,"unlisted":false,"editUrl":"https://github.com/jcmunuera/engineer-portal-docs/edit/main/../docs/ADRs/adr-001-Transactional-APIs.md","tags":[{"inline":true,"label":"Fusion","permalink":"/engineer-portal-docs/docs/tags/fusion"},{"inline":true,"label":"Transaction","permalink":"/engineer-portal-docs/docs/tags/transaction"},{"inline":true,"label":"API","permalink":"/engineer-portal-docs/docs/tags/api"}],"version":"current","frontMatter":{"id":"adr-001-Transactional-APIs","title":"ADR-001: Transactional Support in API-led Connectivity","sidebar_label":"ADR-001: Transactional APIs","date":"2025-05-27T00:00:00.000Z","status":"proposed","author":"Fusion Architecture Team","tags":["Fusion","Transaction","API"]},"sidebar":"docSidebar","previous":{"title":"ADR-000: First Item","permalink":"/engineer-portal-docs/docs/ADRs/adr-000-First-Item"},"next":{"title":"ADR-002: Distributed Electronic Journal","permalink":"/engineer-portal-docs/docs/ADRs/adr-002-Distributed-Electronic-Journal"}}');var t=i(4848),a=i(8453);const r={id:"adr-001-Transactional-APIs",title:"ADR-001: Transactional Support in API-led Connectivity",sidebar_label:"ADR-001: Transactional APIs",date:new Date("2025-05-27T00:00:00.000Z"),status:"proposed",author:"Fusion Architecture Team",tags:["Fusion","Transaction","API"]},o=void 0,l={},c=[{value:"Purpose",id:"purpose",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Providing Transactional Support in Composable API Layer",id:"providing-transactional-support-in-composable-api-layer",level:3},{value:"Role of System API Layer",id:"role-of-system-api-layer",level:3},{value:"UI-Specific Role of BFF/Experience API Layer",id:"ui-specific-role-of-bffexperience-api-layer",level:3},{value:"Technical Details",id:"technical-details",level:3},{value:"Diagram",id:"diagram",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Mitigations",id:"mitigations",level:3},{value:"Alternatives Considered",id:"alternatives-considered",level:2},{value:"No Distributed Transaction Support (Eventual Consistency Only)",id:"no-distributed-transaction-support-eventual-consistency-only",level:3},{value:"Two-Phase Commit (2PC) at the API Level",id:"two-phase-commit-2pc-at-the-api-level",level:3},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"purpose",children:"Purpose"}),"\n",(0,t.jsx)(n.p,{children:"The purpose of this ADR is to document the architectural decision to implement transactional support in API connected applications within our distributed microservices architecture. This decision aims to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Enable reliable, orchestrated management of complex business workflows that span multiple business domains."}),"\n",(0,t.jsx)(n.li,{children:"Maintain clear separation of concerns between orchestration, business logic, and system integrations."}),"\n",(0,t.jsx)(n.li,{children:"Promote reusability, consistency, and decentralization of system integration contracts, particularly in a distributed, multi-location context."}),"\n",(0,t.jsx)(n.li,{children:"Ensure flexible, resilient, and maintainable transaction management strategies aligned with our organizational needs."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This ADR provides the rationale, scope, and guidance for implementing the outlined architecture, facilitating a consistent approach for development teams and stakeholders involved in designing, building, and maintaining our API ecosystem."}),"\n",(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(n.p,{children:"In our FUSION microservices-based application architecture, we have established a multi-layer API structure to enhance ourapplication's integration capabilities and to facilitate better separation of concerns. The architecture comprises four primary API layers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BFF/Experience API"}),": Serves as the interface between the user interface (UI) and the backend services. It handles UI-specific transformations and optimisations to deliver tailored user experience, while making calls to the composable APIs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Composable API"}),": Acts as an orchestrator, managing the integration and coordination of multiple Domain APIs. It facilitates complex workflows, enabling the development of new features that require interactions across various business doamins."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Domain API"}),": Represents atomic business capabilities corresponding to distinct business domains across the organisation. Each Domain API is designed to perform specific operations and is responsible for its ow data management and business logic."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"System API"}),": Encapsulates connections to specific System of Records (SoR) and third-party applications/APIs."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsx)(n.h3,{id:"providing-transactional-support-in-composable-api-layer",children:"Providing Transactional Support in Composable API Layer"}),"\n",(0,t.jsx)(n.p,{children:"We have decided to implement Transactional Support primarily at the Composable API level for the following reasons:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Orchestration of Multiple Domain Operations"}),": The Composable API layer is responsible for orchestrating calls to multiple Domain APIs. By managing transactionality at this layer, we can ensure all steps within a business workflow are executed seamlessly. In cases where one or more Domain API calls fail, the Composable API can invoke compensation logic, providing a coherent method to maintain data integrity."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Separation of Concerns"}),": Keeping the transaction management centralised within the Composable API ensures the Domain APIs remain focused on their core responsibilities -- implementing bsuiness logic gor individual domains -- while offloading the orchestration concerns to the Composble layer. This separation minimises the coupling between services."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flexibility in Transaction Management"}),": By utilising the SAGA pattern within the Compsable API, we can flexibly choose betweeen orchestration or choreography based on the specific business process requirements. This flexibility allows us to adapt to changing needs without impacting the overall architecture."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"role-of-system-api-layer",children:"Role of System API Layer"}),"\n",(0,t.jsx)(n.p,{children:"The introduction of System APIs will provide several advantages to our architecture:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Standardization Across Locations"}),": System APIs will standardize interactions with SoR and third-party APIs, ensuring that all Domain APIs adhere to the same specifications or contracts regardless of the local system variations. This is particularly beneficial for a multinational organization."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decoupling and Flexibility"}),": System APIs decouple the business logic in Domain APIs from specific technical implementations of SoR and third-party integrations. This allows for greater flexibility to update back-end systems without affecting higher-level business logic."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Improved Maintenance and Scalability"}),": Centralizing management of integrations via System APIs simplifies monitoring, logging, and error handling across diverse SoR interactions. This enables smoother scalability when entering new markets that require additional integrations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistent Error Handling and Security"}),": Standardising error handling and security mechanisms across System APIs ensures a cohesive integration experience while safeguarding sensitive data and managing access uniformly."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"ui-specific-role-of-bffexperience-api-layer",children:"UI-Specific Role of BFF/Experience API Layer"}),"\n",(0,t.jsx)(n.p,{children:"The BFF/Experience API layer will focus on handling user interface requirements, ensuring:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User-Centric Data Handling"}),": This layer will interact with the Composable APIs to fetch and transform data specific to various channels and UI designs, enhancing user experience while abstracting complex transaction management."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Independence from Business Logic"}),": By limiting the BFF layer\u2019s role to UX/UI data transformation and optimization, we maintain a clear divide between user experience and business logic, fostering a clean architecture that can adapt easily to future changes."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"technical-details",children:"Technical Details"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pattern for Transaction Management"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Utilize the SAGA pattern for orchestrating distributed transactions at the Composable API layer."}),"\n",(0,t.jsx)(n.li,{children:"Decide between choreography or orchestration based on business process complexity, with orchestration preferred for more control."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compensation Endpoints in Domain APIs"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Define standard conventions for compensation endpoints (e.g., ",(0,t.jsx)(n.code,{children:"POST /<entity>/compensate"}),") within Domain APIs."]}),"\n",(0,t.jsx)(n.li,{children:"Ensure idempotency and consistency of compensation operations to prevent side effects during retries or failure scenarios."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"API Contracts and Standards"}),"-","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Adopt OpenAPI or similar specifications for defining System, Domain, and Composable API contracts."}),"\n",(0,t.jsx)(n.li,{children:"Version API contracts to manage evolution without breaking consumers."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling & Retry Strategies"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Implement robust error handling at each API level, including retries with exponential backoff, circuit breakers, and fallback mechanisms."}),"\n",(0,t.jsx)(n.li,{children:"Propagate meaningful error responses to facilitate debugging and remediation."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event-Driven Communication"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Consider leveraging async messaging or event sourcing within the SAGA orchestration to decouple steps and handle eventual consistency."}),"\n",(0,t.jsx)(n.li,{children:"Use message brokers (e.g., Kafka, PubSub) for reliable event delivery and state management."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Security & Authentication"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Standardize security mechanisms across System APIs, using OAuth2, mutual TLS, or API keys."}),"\n",(0,t.jsx)(n.li,{children:"Manage and rotate credentials centrally, especially for third-party or external integrations."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Observability & Monitoring"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Instrument all API calls with distributed tracing (e.g., Splunk, OpenTelemetry) for end-to-end observability."}),"\n",(0,t.jsx)(n.li,{children:"Log transaction steps, failures, and compensations for auditability and troubleshooting."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Consistency & Idempotency"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use idempotent operations for compensation and critical API actions to prevent duplicate effects."}),"\n",(0,t.jsx)(n.li,{children:"Define explicit data consistency models (e.g., eventual consistency) suitable for the transactional scope."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deployment & Scalability"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Deploy System and API gateways using container orchestration platforms (e.g., Kubernetes)."}),"\n",(0,t.jsx)(n.li,{children:"Ensure horizontal scalability, especially for the Composable layer handling complex workflows."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documentation & Developer Guidance"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Maintain comprehensive API documentation, including transaction flows, compensation logic, error handling, and versioning policies."}),"\n",(0,t.jsx)(n.li,{children:"Provide reference implementations (ERIs) for key transaction patterns to promote consistency."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"diagram",children:"Diagram"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"API Layer picture",src:i(9317).A+"",width:"535",height:"558"})}),"\n",(0,t.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robust Transaction Management"}),": Centralizing transactional support at the Composable API level enables orchestrated workflows that maintain data consistency across multiple domains, reducing manual coordination efforts."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enhanced Flexibility and Scalability"}),": Utilizing the SAGA pattern allows the system to adapt transaction flows dynamically, supporting both orchestrated and choreographed approaches as needed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reusability and Standardization"}),": The introduction of System APIs promotes contract reuse across multiple locations, improving consistency and simplifying integration management across the organization."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Separation of Concerns"}),": Delegating compensation logic to Domain APIs helps keep business logic encapsulated, simplifying maintenance and evolution of services."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Increased Complexity"}),": Implementing distributed transaction management and compensation logic adds complexity to both development and operational processes, requiring careful design, testing, and monitoring."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Latency and Performance Overhead"}),": Orchestrated workflows, especially involving multiple API calls and compensation steps, can introduce increased latency and resource consumption, impacting user experience."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Propagation and Partial Failures"}),": Handling failures gracefully across multiple systems requires robust error handling and monitoring to prevent inconsistencies or incomplete transactions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Potential for Inconsistent State"}),": Despite compensation efforts, some failure scenarios may leave the system in an inconsistent state if compensating actions are not correctly implemented or invoked."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.h3,{id:"mitigations",children:"Mitigations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Design for Idempotency and Consistency"}),": Enforce idempotent operations for compensation endpoints and transactional steps to prevent side effects from retries or duplicate messages."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implement Robust Monitoring and Alerts"}),": Leverage distributed tracing, logging, and alerting tools to detect and respond swiftl  y to failures, enabling prompt recovery and troubleshooting."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optimize for Performance"}),": Use asynchronous messaging and event sourcing where appropriate to reduce latency impacts and decouple transaction steps, improving overall system responsiveness."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gradual Adoption and Testing"}),": Start with critical or high-value workflows, rigorously test transaction paths, and incrementally extend support to other areas to manage complexity and risk."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clear Documentation"}),": Provide comprehensive documentation on transaction flows, compensation mechanisms, error handling, and recovery procedures to ensure alignment and clarity across teams."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.h3,{id:"no-distributed-transaction-support-eventual-consistency-only",children:"No Distributed Transaction Support (Eventual Consistency Only)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Rely solely on eventual consistency mechanisms, with each Domain API operating independently without coordinated transaction management."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rationale for Discarding"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This approach simplifies implementation but sacrifices data consistency guarantees necessary for certain critical business workflows.\nIn scenarios involving multiple updates across domains, it can lead to data anomalies, making it unsuitable for workflows requiring transactional integrity."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.h3,{id:"two-phase-commit-2pc-at-the-api-level",children:"Two-Phase Commit (2PC) at the API Level"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Implement a distributed transaction protocol such as 2PC across services using a two-phase commit mechanism."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rationale for Discarding"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"2PC introduces significant complexity, coordination overhead, and potential blocking issues in a distributed microservices environment.\nIt reduces system availability and scalability\u2014issues that are contrary to microservices principles and organizational scalability goals.\nGiven the asynchronous and loosely coupled nature of our architecture, 2PC was deemed too rigid and impractical."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://microservices.io/patterns/data/saga.html",children:"SAGA Pattern"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"ERIs/eri-0011-Transactional-Management",children:"ERI - Transactional Management Implementation"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},9317:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/adr-001-Api-Layer-light-d1559bba47a69753ab82e8d11a49c9c8.png"}}]);