const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

module.exports = function firstDocPathPlugin(context, options) {
  
  return {
    name: 'first-doc-path-plugin',
    async loadContent() {
      try {
        // Cargar el sidebar desde sidebars.js
        const sidebars = require('../../sidebars.js');
        const docSidebar = sidebars.docSidebar;

        let firstDocId = 'ADRs/adr-000-First-Item'; // Fallback
        let selectedDirName = 'ADRs'; // Fallback dirName
        if (docSidebar && docSidebar.length > 0) {
          const firstCategory = docSidebar.find((item) => item.type === 'category');
          
          if (firstCategory && firstCategory.items.length > 0) {
            const autogeneratedItem = firstCategory.items.find((item) => item.type === 'autogenerated');
            
            if (autogeneratedItem && autogeneratedItem.dirName) {
              selectedDirName = autogeneratedItem.dirName;
              
              // Construir el directorio dinámicamente
              const docsDir = path.resolve(__dirname, '../../../docs', selectedDirName);
              
              // Validar que el directorio exista
              if (fs.existsSync(docsDir)) {
                const files = fs.readdirSync(docsDir)
                  .filter(f => f.endsWith('.md') || f.endsWith('.mdx'))
                  .map(file => ({ file, path: path.join(docsDir, file) }));

                if (files.length > 0) {
                  // Ordenar por sidebar_position (menor primero) o alfabéticamente
                  const sortedFiles = files.sort((a, b) => {
                    try {
                      const contentA = fs.readFileSync(a.path, 'utf8');
                      const contentB = fs.readFileSync(b.path, 'utf8');
                      const frontMatterA = contentA.match(/^---\n([\s\S]*?)\n---/)?.[1] || '';
                      const frontMatterB = contentB.match(/^---\n([\s\S]*?)\n---/)?.[1] || '';
                      const metaA = yaml.load(frontMatterA) || {};
                      const metaB = yaml.load(frontMatterB) || {};
                      const posA = metaA.sidebar_position || Infinity;
                      const posB = metaB.sidebar_position || Infinity;
                      if (posA !== posB) return posA - posB;
                      return a.file.localeCompare(b.file);
                    } catch (e) {
                      return a.file.localeCompare(b.file);
                    }
                  });

                  const firstFile = sortedFiles[0].file;
                  firstDocId = `${selectedDirName}/${firstFile.replace(/\.mdx?$/, '')}`;
                }
              } else {
                console.log('[first-doc-path-plugin] Directory does not exist:', docsDir);
              }
            }
          }
        }

        return { firstDocId };
      } catch (error) {
        throw error;
      }
    },
    async contentLoaded({ content, actions }) {
      const { firstDocId } = content;
      const { setGlobalData } = actions;
      setGlobalData({ firstDocPath: firstDocId });
    },
  };
};

